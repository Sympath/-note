###  **隐式转换**

在js中，当运算符在运算时，如果两边数据不统一，CPU就无法计算，这时我们编译器会自动将运算符两边的数据做一个数据类型转换，转成一样的数据类型再计算

这种无需程序员手动转换，而由编译器自动转换的方式就称为隐式转换例如1 > "0"这行代码在js中并不会报错，编译器在运算符时会先把右边的"0"转成数字0`然后在比较大小

#### 隐式转换规则

###### 基本规则

- 转为布尔类型为false的七+一种情况：0 -0 NaN undefined null '空串' false 

  - docunment.all  

    ```
    IE对document有个属性是all,表示所有的DOM对象。
    网上有人说这句话能判断浏览器是否IE，现在是不行的，因为很多别的浏览器也支持这个，所以，现在这句话没什么用，从语句上理解，就是判断这个网页存不存在DOM的对象，就是存不存在document啦。
    ```

- 转成string类型： +（字符串连接符） 
- 转成number类型：
  1. ++/--   (自增自减运算符) 
  2. \+ \- * / %   (算术运算符) 
  3.  \> \< >= <= == != === !===   (关系运算符)

- 转成boolean类型：!（逻辑非运算符）

###### 经典情况分析

 -  +号
    1. 两边存在字符串  为字符串连接符  会将其他类型通过调用String()类型转换方法转换后进行字符串拼接(此处其实就是我们经常说的字符串重载+，而本质上即是在调用字符串拼接方法，基本包装类出现后调用然后被销毁，于是也体现了字符串的不可变性)
    2. 无字符串 为算术运算符 会调用Number()方法后计算 注意Number(undefined)==NaN

- 关系运算符

  1. 关系运算符两边均为string时，并不是通过Number()进行转换后比较，而是直接进行unicode码进行比较（ps：字符串.charCodeAt(字符串下标默认为0) 可以获得字符串中字符对应码值）
  2. 特殊情况，无视规章
     1. undefined == undefined   true
     2. undefined == null     true
     3. null  == null   true
     4. NaN 不等于任何

  3. 复杂数据类型在隐式转换时
     1. 会先通过valueOf()看得到是否为number，
     2. 若不是则再用toString()先转成String，然后再转成Number运算

     ![](http://p9.pstatp.com/large/pgc-image/1538025621414c490c46b28)

  



###### 经典面试题

![](http://p9.pstatp.com/large/pgc-image/153802573916560e7c21b31)

###### 原理分析

#### ![解释](http://p98.pstatp.com/large/pgc-image/1538025799063ed1e9da3cf)

###### 一些特殊点

1. 空数组的toString()方法会得到空字符串，而空对象的toString()方法会得到字符串`[object Object]` （注意第一个小写o，第二个大写O
2. 对象和对象比较的是地址值